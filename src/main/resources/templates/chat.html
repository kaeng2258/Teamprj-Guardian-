<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Guardian Chat + WebRTC (Horizontal · Auto-Subscribe)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- SockJS + STOMP -->
  <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
  <style>
    :root{
      --bg:#0b1020;--panel:#0b1220;--panel2:#0a0f1c;
      --text:#e5e7eb;--muted:#9ca3af;--ok:#10b981;--warn:#f59e0b;--err:#ef4444;
      --blue:#2563eb;--blue2:#1d4ed8;--gray:#6b7280;--gray2:#4b5563;--border:#1f2937;
    }
    *{box-sizing:border-box}
    html,body{height:100%; overflow:hidden;}
    body{margin:0;background:linear-gradient(180deg,#0b1020,#0f172a);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Apple SD Gothic Neo,sans-serif}

    /* 전체 레이아웃: 좌(영상) 60% / 우(채팅) 40% */
    .shell{height:100vh;display:grid;grid-template-columns:3fr 2fr;gap:12px;padding:12px;overflow:hidden}

    /* 좌측: 영상 영역 */
    .left{display:grid;grid-template-rows:auto 1fr;gap:12px;min-width:0;overflow:hidden}
    .avbar{display:flex;gap:8px;align-items:center;padding:8px 12px;background:linear-gradient(180deg,#0b1220,#0a0f1c);border:1px solid var(--border);border-radius:12px;flex-wrap:wrap}
    .btn{padding:8px 12px;border-radius:10px;border:0;background:linear-gradient(180deg,var(--blue),var(--blue2));color:#fff;font-weight:700;cursor:pointer}
    .btn.secondary{background:linear-gradient(180deg,var(--gray),var(--gray2))}
    .hint{color:var(--muted);font-size:12px;margin-left:6px}
    .videoPanel{display:grid;grid-template-rows:auto 1fr;gap:8px;background:linear-gradient(180deg,#0b1220,#0a0f1c);border:1px solid var(--border);border-radius:12px;padding:10px;min-height:0;overflow:hidden}

    /* 가로형(1행 2열) 동일 비율 */
    .videoGrid{
      display:grid;
      grid-template-columns:1fr 1fr;
      grid-auto-rows: 1fr;
      gap:8px;
      min-height:0;
      overflow:hidden;
    }
    .tile{position:relative;background:#000;border-radius:10px;overflow:hidden;border:1px solid var(--border);min-height:0}
    .tile small{position:absolute;left:8px;top:6px;color:#cbd5e1;font-size:12px;background:rgba(0,0,0,.35);padding:2px 6px;border-radius:999px}
    video{width:100%;height:100%;object-fit:contain;background:#000;display:block}

    /* 우측: 채팅 + 스레드 (스크롤은 "채팅 박스"에만) */
    .right{display:grid;grid-template-rows:auto auto 1fr auto;gap:10px;min-width:0;overflow:hidden}
    .roomBar{display:flex;gap:10px;align-items:center;background:linear-gradient(180deg,#0b1220,#0a0f1c);border:1px solid var(--border);border-radius:12px;padding:10px 12px}
    .toolbar{margin-left:auto;display:flex;gap:6px;align-items:center;flex-wrap:wrap}
    .toolbar input{width:110px;padding:6px 8px;border-radius:8px;border:1px solid #334155;background:#0c1426;color:var(--text)}

    .threads{background:linear-gradient(180deg,#0b1220,#0a0f1c);border:1px solid var(--border);border-radius:12px;padding:8px;max-height:180px;overflow:auto}
    .th{padding:8px;border-radius:8px;cursor:pointer;border:1px solid transparent;display:grid;grid-template-columns:1fr auto;gap:6px}
    .th:hover{background:#0d1730}.th.active{background:#0a1a33;border-color:#1e3a8a}
    .th .name{font-weight:700}
    .th .snippet{color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:260px}
    .th .time{color:#7aa2f7;font-size:12px}

    .msgsWrap{
      position:relative;
      background:linear-gradient(180deg,#0b1220,#0a0f1c);
      border:1px solid var(--border);
      border-radius:12px;
      min-height:0;
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .msgs{
      flex:1;
      overflow:auto;
      padding:12px;
      min-height:0;
    }
    .empty{color:var(--muted);text-align:center;padding:24px}
    .bubble{max-width:82%;margin:6px 0;padding:10px 12px;border-radius:14px;word-break:break-word}
    .mine{margin-left:auto;background:linear-gradient(180deg,#1a5fff,#1448be)}
    .other{background:#1f2937;border:1px solid #2a3648}
    .metaRow{display:flex;gap:8px;align-items:center;margin-top:4px;color:var(--muted);font-size:12px}
    .jump{position:absolute;right:12px;bottom:54px;padding:6px 10px;border-radius:999px;background:#111827;border:1px solid #334155;color:#cbd5e1;cursor:pointer;display:none}
    .jump.show{display:block}

    .composer{display:flex;gap:8px;align-items:center;padding:10px 12px;background:linear-gradient(180deg,#0b1220,#0a0f1c);border:1px solid var(--border);border-radius:12px}
    .composer input{flex:1;padding:12px 14px;border-radius:999px;border:1px solid #1f2937;background:#0c1426;color:var(--text)}

    .status{font-size:12px}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
  </style>
</head>
<body>
<div class="shell">

  <!-- 왼쪽: 영상 (가로 2분할) -->
  <section class="left">
    <div class="avbar">
      <button class="btn" id="btnCam">카메라 켜기</button>
      <button class="btn secondary" id="btnMic">마이크 켜기</button>
      <button class="btn" id="btnShare">화면공유 시작</button>
      <span class="hint">카메라만 켜면 자동 연결/송출됩니다.</span>
    </div>

    <div class="videoPanel">
      <div><span id="net" class="status warn">WS 연결 안 됨</span></div>
      <div class="videoGrid">
        <div class="tile"><small>내 미리보기</small><video id="localVideo" autoplay playsinline muted></video></div>
        <div class="tile"><small>상대 영상</small><video id="remoteVideo" autoplay playsinline></video></div>
      </div>
    </div>
  </section>

  <!-- 오른쪽: 채팅 -->
  <section class="right">
    <div class="roomBar">
      <div>
        <div style="font-weight:800" id="roomTitle">채팅방 미선택</div>
        <div class="status" id="roomMeta">내 ID를 입력하고 방을 선택하세요</div>
      </div>
      <div class="toolbar">
        <input id="meId" type="number" placeholder="내 ID" />
        <input id="clientId" type="number" placeholder="clientId" />
        <input id="managerId" type="number" placeholder="managerId" />
        <button class="btn" id="btnOpen">방 생성/획득</button>
        <button class="btn secondary" id="btnDelete">방 삭제</button>
      </div>
    </div>

    <div class="threads" id="threads"></div>

    <div class="msgsWrap">
      <div class="msgs" id="msgs"><div class="empty">메시지가 없습니다.</div></div>
      <button class="jump" id="btnJump">맨 아래로 ↓</button>
    </div>

    <div class="composer">
      <input id="msg" placeholder="메시지를 입력하세요 (Enter 전송)" />
      <button class="btn" id="btnSend">Send</button>
    </div>
  </section>
</div>

<script>
  // ===== API =====
  const API = '';
  const ENDPOINTS = {
    threads: (userId) => `${API}/api/chat/threads?userId=${encodeURIComponent(userId)}`,
    messages: (roomId) => `${API}/api/chat/rooms/${roomId}/messages`,
    send: (roomId) => `${API}/api/chat/rooms/${roomId}/messages`,
    read: (roomId, userId) => `${API}/api/chat/rooms/${roomId}/read?userId=${encodeURIComponent(userId)}`,
    openRoom: () => `${API}/api/chat/rooms`,
    deleteRoom: (roomId, userId) => `${API}/api/chat/rooms/${roomId}?userId=${encodeURIComponent(userId)}`
  };

  // ===== 요소 =====
  const els = {
    // 좌측
    btnCam: document.getElementById('btnCam'),
    btnMic: document.getElementById('btnMic'),
    btnShare: document.getElementById('btnShare'),
    localVideo: document.getElementById('localVideo'),
    remoteVideo: document.getElementById('remoteVideo'),
    net: document.getElementById('net'),

    // 우측
    meId: document.getElementById('meId'),
    clientId: document.getElementById('clientId'),
    managerId: document.getElementById('managerId'),
    btnOpen: document.getElementById('btnOpen'),
    btnDelete: document.getElementById('btnDelete'),
    roomTitle: document.getElementById('roomTitle'),
    roomMeta: document.getElementById('roomMeta'),

    threads: document.getElementById('threads'),
    msgs: document.getElementById('msgs'),
    btnJump: document.getElementById('btnJump'),
    input: document.getElementById('msg'),
    btnSend: document.getElementById('btnSend'),
  };

  // ===== 상태 =====
  let stomp = null, subChat = null, subRtc = null;
  let currentRoomId = null, me = null;
  const seen = new Set();
  let pc = null, localStream = null, screenStream = null;
  let camOn = false, micOn = false;
  let negotiating = false;

  // ✅ 스레드 실시간 갱신용
  let threadsCache = [];
  const threadSubs = new Map(); // roomId -> subscription

  const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

  // ===== 유틸 =====
  const fmt = (iso) => {
    if (!iso) return '';
    const d = new Date(iso);
    const yy = d.getFullYear().toString().slice(-2);
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    const hh = String(d.getHours()).padStart(2,'0');
    const mi = String(d.getMinutes()).padStart(2,'0');
    return `${yy}/${mm}/${dd} ${hh}:${mi}`;
  };
  const escapeHtml = (s='') => s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  const nearBottom = () => (els.msgs.scrollHeight - els.msgs.scrollTop - els.msgs.clientHeight) < 80;

  // ===== 채팅 렌더 =====
  function renderMsg(m, mine){
    const key = m.messageId ?? `${m.senderId}|${m.sentAt}|${m.content}`;
    if (seen.has(key)) return;
    seen.add(key);

    const wrap = document.createElement('div');
    wrap.className = `bubble ${mine ? 'mine' : 'other'}`;
    wrap.innerHTML = `<div>${escapeHtml(m.content ?? '')}</div>
      <div class="metaRow"><span>${m.messageType ?? 'TEXT'}</span><span>·</span><span>${fmt(m.sentAt)}</span>
      ${m.senderId ? `<span>·</span><span>#${m.senderId}</span>`:''}</div>`;
    els.msgs.appendChild(wrap);

    if (nearBottom()) els.msgs.scrollTop = els.msgs.scrollHeight;
    else els.btnJump.classList.add('show');
  }

  function renderThreads(list){
    threadsCache = list.slice(); // ✅ 캐시 업데이트
    const cur = currentRoomId;
    els.threads.innerHTML = '';
    list.sort((a,b)=> new Date(b.lastMessageAt||0) - new Date(a.lastMessageAt||0));
    list.forEach(t=>{
      const n = document.createElement('div');
      n.className = 'th';
      n.dataset.roomId = t.roomId;
      n.innerHTML = `<div><div class="name">Room #${t.roomId} (${t.clientId}↔${t.managerId})</div>
        <div class="snippet">${escapeHtml(t.lastMessageSnippet||'')}</div></div>
        <div class="time">${fmt(t.lastMessageAt)}</div>`;
      n.onclick = ()=>selectRoom(t.roomId);
      if (t.roomId===cur) n.classList.add('active');
      els.threads.appendChild(n);
    });
  }

  // ===== 스레드 미니 구독: 새 메시지 오면 목록 시간/스니펫 즉시 갱신 =====
  function ensureThreadSubscriptions(list){
    if (!stomp || !stomp.connected) return;
    const needed = new Set(list.map(t => t.roomId));

    // 새 구독 추가
    for (const t of list){
      if (threadSubs.has(t.roomId)) continue;
      const sub = stomp.subscribe(`/topic/room/${t.roomId}`, (frame)=>{
        const m = JSON.parse(frame.body);
        // 캐시 갱신
        const idx = threadsCache.findIndex(x => x.roomId === t.roomId);
        if (idx >= 0) {
          threadsCache[idx] = {
            ...threadsCache[idx],
            lastMessageAt: m.sentAt,
            lastMessageSnippet: m.content ?? ''
          };
        } else {
          // 안전망: 캐시에 없으면 추가
          threadsCache.push({
            roomId: t.roomId,
            clientId: t.clientId,
            managerId: t.managerId,
            lastMessageAt: m.sentAt,
            lastMessageSnippet: m.content ?? ''
          });
        }
        // 다시 정렬/렌더(현재 선택 강조 유지)
        renderThreads(threadsCache);
      });
      threadSubs.set(t.roomId, sub);
    }

    // 불필요 구독 제거
    for (const [roomId, sub] of threadSubs.entries()){
      if (!needed.has(roomId)) {
        try { sub.unsubscribe(); } catch(_) {}
        threadSubs.delete(roomId);
      }
    }
  }

  // ===== 데이터 로딩 =====
  async function loadThreads(){
    if (!me) return;
    const r = await fetch(ENDPOINTS.threads(me));
    if(!r.ok) return;
    const list = await r.json();
    renderThreads(list);

    // ✅ 내 모든 방에 미니 구독
    ensureThreadSubscriptions(list);

    // 아직 방이 없으면 최근 방 자동 선택
    if (!currentRoomId && list.length > 0) {
      await selectRoom(list[0].roomId);
    }
  }

  async function loadMessages(roomId){
    const r = await fetch(ENDPOINTS.messages(roomId));
    if(!r.ok) throw new Error('load messages failed');
    return await r.json();
  }

  async function markRead(roomId){
    if(!me) return;
    fetch(ENDPOINTS.read(roomId, me), {method:'POST'}).catch(()=>{});
  }

  // ===== 방 선택 =====
  async function selectRoom(roomId){
    currentRoomId = roomId;
    localStorage.setItem('guardian.room', String(roomId)); // 마지막 방 기억

    seen.clear();
    document.querySelectorAll('.th').forEach(n=>n.classList.toggle('active', Number(n.dataset.roomId)===roomId));
    els.roomTitle.textContent = `Room #${roomId}`;
    els.roomMeta.textContent = me ? `내 ID: ${me} · 실시간 수신 중` : '내 ID를 입력하세요';

    els.msgs.innerHTML = '<div class="empty">메시지가 없습니다.</div>';
    const list = await loadMessages(roomId);
    els.msgs.innerHTML = '';
    list.forEach(m => renderMsg(m, m.senderId===me));
    els.msgs.scrollTop = els.msgs.scrollHeight;
    els.btnJump.classList.remove('show');
    await markRead(roomId);
    subscribe(roomId); // ✅ 본문 구독 갱신
  }

  // ===== STOMP =====
  function connectWS(){
    if (stomp?.connected) return;
    const sock = new SockJS('/ws');
    stomp = Stomp.over(sock);
    stomp.debug = null;
    stomp.connect({}, () => {
      els.net.textContent = 'WS 연결됨'; els.net.className = 'status ok';
      // 현재 방 본문 재구독
      if (currentRoomId) subscribe(currentRoomId);
      // ✅ 스레드 미니 구독 복구
      if (threadsCache.length) ensureThreadSubscriptions(threadsCache);
    }, () => {
      els.net.textContent = 'WS 연결 끊김'; els.net.className = 'status err';
    });
  }

  function subscribe(roomId){
    if (!stomp || !stomp.connected) return;
    if (subChat) { subChat.unsubscribe(); subChat = null; }
    if (subRtc)  { subRtc.unsubscribe();  subRtc  = null; }

    // 채팅 실시간 수신 (본문)
    subChat = stomp.subscribe(`/topic/room/${roomId}`, (frame)=>{
      const m = JSON.parse(frame.body);
      renderMsg(m, m.senderId===me);

      // 스레드 타임/스니펫도 함께 캐시 반영 (선택 방도 최신화)
      const idx = threadsCache.findIndex(x => x.roomId === roomId);
      if (idx >= 0) {
        threadsCache[idx] = { ...threadsCache[idx], lastMessageAt: m.sentAt, lastMessageSnippet: m.content ?? '' };
        renderThreads(threadsCache); // 정렬 반영
      }
    });

    // RTC 시그널링
    subRtc = stomp.subscribe(`/topic/rtc/${roomId}`, (frame)=>{
      const sig = JSON.parse(frame.body); // {type, from, sdp?, candidate?}
      handleRtc(sig);
    });
  }

  // ===== 채팅 전송: STOMP 우선 =====
  async function sendChat(){
    if(!me){ alert('내 사용자 ID'); return; }
    if(!currentRoomId){ alert('방을 먼저 선택하세요'); return; }
    const text = els.input.value.trim();
    if(!text) return;

    if (stomp && stomp.connected) {
      const payload = { roomId: currentRoomId, senderId: me, content: text, messageType: 'TEXT', fileUrl: null };
      stomp.send(`/app/signal/${currentRoomId}`, {}, JSON.stringify(payload));
      els.input.value = '';
    } else {
      // WS 끊김 시 HTTP 폴백(낙관적 렌더)
      const temp = {
        messageId: `temp-${Date.now()}-${Math.random()}`,
        senderId: me,
        sentAt: new Date().toISOString(),
        messageType: 'TEXT',
        content: text
      };
      renderMsg(temp, true);
      els.input.value = '';

      try {
        const r = await fetch(ENDPOINTS.send(currentRoomId), {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({
            roomId: currentRoomId,
            senderId: me,
            content: text,
            messageType: 'TEXT',
            fileUrl: null
          })
        });
        if(!r.ok){ console.warn('HTTP send non-2xx', r.status); }
      } catch(e){ console.warn('HTTP send error', e); }
    }
  }

  // ===== 방 생성/삭제 =====
  async function openRoom(){
    const c = Number(els.clientId.value||0), p = Number(els.managerId.value||0);
    if(!c || !p){ alert('clientId/managerId'); return; }
    const r = await fetch(ENDPOINTS.openRoom(), {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({clientId:c, managerId:p})
    });
    if(!r.ok){ alert('방 생성 실패'); return; }
    const room = await r.json();
    await loadThreads();
    await selectRoom(room.roomId); // 생성 직후 구독
  }

  async function deleteRoom(){
    if(!currentRoomId){ alert('방 선택'); return; }
    if(!me){ alert('내 사용자 ID'); return; }
    if(!confirm(`Room #${currentRoomId} 삭제?`)) return;
    const r = await fetch(ENDPOINTS.deleteRoom(currentRoomId, me), { method:'DELETE' });
    if(!r.ok){ alert('삭제 실패'); return; }
    currentRoomId=null;
    localStorage.removeItem('guardian.room');
    els.roomTitle.textContent='채팅방 미선택';
    els.roomMeta.textContent='내 ID를 입력하고 방을 선택하세요';
    els.msgs.innerHTML='<div class="empty">메시지가 없습니다.</div>';
    await loadThreads();
    hangup();
  }

  // ===== WebRTC =====
  function ensurePC(){
    if (pc) return pc;
    pc = new RTCPeerConnection(rtcConfig);

    pc.onicecandidate = (e)=>{ if(e.candidate) sendRtc('candidate', { candidate: e.candidate }); };

    pc.ontrack = (e)=>{
      const stream = e.streams[0];
      els.remoteVideo.srcObject = stream;
      stream.getTracks().forEach(track=>{
        const clear = ()=>{ els.remoteVideo.srcObject = null; };
        track.addEventListener('ended', clear);
        track.addEventListener('mute', clear);
      });
    };

    pc.onnegotiationneeded = async ()=>{
      try{
        if (negotiating) return;
        negotiating = true;
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        sendRtc('offer', { sdp: offer.sdp });
      } finally { negotiating = false; }
    };

    return pc;
  }

  function videoSender(){ return pc?.getSenders()?.find(s => s.track && s.track.kind === 'video') || null; }
  function audioSender(){ return pc?.getSenders()?.find(s => s.track && s.track.kind === 'audio') || null; }

  async function startCamera(){
    if (camOn) return;
    try{
      localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
      els.localVideo.srcObject = localStream;
      camOn = true; micOn = true; els.btnCam.textContent = '카메라 끄기'; els.btnMic.textContent='마이크 끄기';

      ensurePC();
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      sendRtc('video-on', {});
    }catch(e){
      alert('카메라 실패: '+e.message);
    }
  }

  async function stopCamera(){
    if (!camOn) return;
    localStream?.getTracks().forEach(t=>t.stop());
    localStream = null;
    els.localVideo.srcObject = screenStream || null;
    camOn = false; els.btnCam.textContent='카메라 켜기';

    ensurePC();
    const vs = videoSender(); if (vs) { try { await vs.replaceTrack(null); } catch(_){} }
    const as = audioSender(); if (as) { try { await as.replaceTrack(null); } catch(_){} }

    const vTrans = pc.getTransceivers().find(t=>t.sender===vs);
    if (vTrans) vTrans.direction = 'recvonly';
    const aTrans = pc.getTransceivers().find(t=>t.sender===as);
    if (aTrans) aTrans.direction = 'recvonly';

    sendRtc('video-off', {});
  }

  function toggleMic(){
    if (!localStream){ alert('먼저 카메라 켜기'); return; }
    micOn = !micOn;
    localStream.getAudioTracks().forEach(t => t.enabled = micOn);
    els.btnMic.textContent = micOn ? '마이크 끄기' : '마이크 켜기';
  }

  async function startShare(){
    if (screenStream) return;
    try{
      const getDisplay = (navigator.mediaDevices?.getDisplayMedia)
        ? navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices)
        : (navigator.getDisplayMedia ? navigator.getDisplayMedia.bind(navigator) : null);
      if (!getDisplay){ alert('화면공유 미지원 브라우저입니다.'); return; }

      screenStream = await getDisplay({ video:true, audio:false });
      els.localVideo.srcObject = screenStream || localStream || null;

      ensurePC();
      const vTrack = screenStream.getVideoTracks()[0];
      const sender = videoSender();
      if (sender && vTrack) await sender.replaceTrack(vTrack);
      else if (vTrack) pc.addTrack(vTrack, screenStream);

      els.btnShare.textContent = '화면공유 중지';
      screenStream.getVideoTracks()[0].addEventListener('ended', stopShare);
    }catch(e){ alert('화면공유 실패: '+e.message); }
  }

  async function stopShare(){
    if (!screenStream) return;
    screenStream.getTracks().forEach(t=>t.stop());
    screenStream = null;
    els.localVideo.srcObject = localStream || null;

    ensurePC();
    const vTrack = localStream?.getVideoTracks?.()[0] || null;
    const sender = videoSender();
    if (sender){
      if (vTrack) await sender.replaceTrack(vTrack);
      else { try { await sender.replaceTrack(null); } catch(_){} }
    }
    els.btnShare.textContent = '화면공유 시작';
  }

  function hangup(){
    try { pc?.getSenders()?.forEach(s=>{ try{ pc.removeTrack(s); }catch(_){}}); } catch(_){}
    try { pc?.close(); } catch(_){}
    pc = null; els.remoteVideo.srcObject = null;
  }

  // ===== 시그널 =====
  function sendRtc(type, payload){
    if (!stomp || !stomp.connected || !currentRoomId || !me) return;
    const body = { type, from: me, ...payload };
    stomp.send(`/app/rtc/${currentRoomId}`, {}, JSON.stringify(body));
  }

  async function handleRtc(msg){
    if (msg.from === me) return;
    ensurePC();

    if (msg.type === 'offer'){
      await pc.setRemoteDescription({ type:'offer', sdp: msg.sdp });
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      sendRtc('answer', { sdp: answer.sdp });
    } else if (msg.type === 'answer'){
      await pc.setRemoteDescription({ type:'answer', sdp: msg.sdp });
    } else if (msg.type === 'candidate' && msg.candidate){
      try { await pc.addIceCandidate(new RTCIceCandidate(msg.candidate)); } catch(e){ console.error(e); }
    } else if (msg.type === 'video-off'){
      els.remoteVideo.srcObject = null;
    }
  }

  // ===== 이벤트 =====
  els.btnSend.onclick = sendChat;
  els.input.addEventListener('keydown', e => { if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendChat(); }});
  els.btnOpen.onclick = openRoom;
  els.btnDelete.onclick = deleteRoom;

  els.btnCam.onclick = ()=> camOn ? stopCamera() : startCamera();
  els.btnMic.onclick = toggleMic;
  els.btnShare.onclick = ()=> screenStream ? stopShare() : startShare();

  els.meId.onchange = ()=>{
    me = Number(els.meId.value||0) || null;
    localStorage.setItem('guardian.me', me || '');
    loadThreads(); // 가장 최근 방 자동 선택 + 스레드 미니구독
  };

  // 채팅 박스 전용 스크롤 UX
  els.msgs.addEventListener('scroll', ()=>{
    if (nearBottom()) els.btnJump.classList.remove('show');
    else els.btnJump.classList.add('show');
  });
  els.btnJump.onclick = ()=>{ els.msgs.scrollTop = els.msgs.scrollHeight; els.btnJump.classList.remove('show'); };

  // ===== URL 파라미터 =====
  function getParams(){
    const p = new URLSearchParams(location.search);
    return {
      me: Number(p.get('me')||0) || null,
      client: Number(p.get('client')||0) || null,
      manager: Number(p.get('manager')||0) || null
    };
  }

  // ===== 초기화 (자동 복구 + 자동 선택) =====
  (async function init(){
    const params = getParams();
    const savedMe   = Number(localStorage.getItem('guardian.me') || 0) || null;
    const savedRoom = Number(localStorage.getItem('guardian.room') || 0) || null;

    if (params.me) { me = params.me; els.meId.value = me; localStorage.setItem('guardian.me', me); }
    else if (savedMe) { me = savedMe; els.meId.value = savedMe; }

    connectWS(); // WS 먼저

    if (me) {
      await loadThreads(); // 현재 방 없으면 최신 방 자동 선택

      // URL이 client/manager를 주면 즉시 방 생성/획득 후 구독
      if (params.client && params.manager) {
        try{
          const r = await fetch(ENDPOINTS.openRoom(), {
            method:'POST', headers:{'Content-Type':'application/json'},
            body: JSON.stringify({clientId: params.client, managerId: params.manager})
          });
          if (r.ok) {
            const room = await r.json();
            await selectRoom(room.roomId);
          }
        }catch(_){}
      } else if (savedRoom) {
        // 마지막으로 열었던 방 복구 시도
        try{ await selectRoom(savedRoom); }catch(_){}
      }
    }
  })();
</script>
</body>
</html>
